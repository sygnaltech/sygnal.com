{
  "version": 3,
  "sources": ["../../../src/features/gista/gista.ts"],
  "sourcesContent": ["\n// ORIGIN \n// https://codepen.io/memetican/pen/XWoWxNG/5f4ec4166cb4df430a34dd7b91fff206?editors=0010\n\nexport async function initGistaAsync() {\n\n    // Create a new DOM parser to parse the SVG string\n    let parser: DOMParser = new DOMParser();\n    let svgString: string = `\n        <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 82.146 82.146\">\n            <circle cx=\"31.073\" cy=\"58.368\" r=\"17.288\" stroke-width=\"6\" fill=\"none\" stroke=\"currentColor\"></circle>\n            <circle cx=\"51.073\" cy=\"58.368\" r=\"17.288\" stroke-width=\"6\" fill=\"none\" stroke=\"currentColor\"></circle>\n            <circle cx=\"61.073\" cy=\"41.047\" r=\"17.288\" stroke-width=\"6\" fill=\"none\" stroke=\"currentColor\"></circle>\n            <circle cx=\"51.073\" cy=\"23.727\" r=\"17.288\" stroke-width=\"6\" fill=\"none\" stroke=\"currentColor\"></circle>\n            <circle cx=\"31.073\" cy=\"23.728\" r=\"17.288\" stroke-width=\"6\" fill=\"none\" stroke=\"currentColor\"></circle>\n            <circle cx=\"21.073\" cy=\"41.047\" r=\"17.288\" stroke-width=\"6\" fill=\"none\" stroke=\"currentColor\"></circle>\n        </svg>`;\n\n    // Convert the SVG string into a DOM node\n    let svgNode: Element = parser.parseFromString(svgString, 'image/svg+xml').documentElement;\n\n    // Get the #gista-embed-button element and its img child\n    // let buttonElement = document.querySelector('#gista-embed-button');\n\n    // Define the callback function that will be called when the element is added\n    function handleNewElement(element: HTMLElement): void {\n        // Modify the element here\n    //    console.log(\"New element added:\", element); \n        \n        element.classList.add('gista-button');\n            // Remove the inline styles for width and height\n        \n        element.style.cssText = '';\n        //    element.style.height = '';\n        //    element.style.bottom = '';\n        //    element.style.right = ''; \n\n        // Replace the img child with the new SVG node \n        // element.replaceChild(svgNode, imgChild);\n        let imgChild: HTMLImageElement | null = element.querySelector('img');\n        if (imgChild) {\n            imgChild.src = 'https://uploads-ssl.webflow.com/59b8d49f7fdf9700017d780f/64e2bfafeccea9001016cfbe_dp_icon_white_trans.svg';\n        }\n                \n    // <img src=\"https://public.gista.co/images/logo/dp_icon_white.png\" alt=\"Button Image\" style=\"width: 100%; height: 100%; border-radius: 9999px;\">\n            \n        //    Webflow.require('ix2').init(); \n            \n        // Set up the MutationObserver to watch the element\n        const mutationCallback: MutationCallback = (mutationsList: MutationRecord[], observer: MutationObserver) => {\n            for(let mutation of mutationsList) {\n                // Handle different types of mutations. \n                // For this example, let's focus on attribute changes\n                if (mutation.type === 'attributes') {\n                    // console.log(`Attribute ${mutation.attributeName} was modified.`);\n                    if (mutation.target instanceof HTMLElement) {\n\n//                        console.log(mutation.target); \n\n                        // Ignore X\n                        if (mutation.target.tagName == \"DIV\" && mutation.target.innerText == '\u2715') {\n                            continue;\n                        }\n\n                        mutationObserver.disconnect();\n\n                        let display = mutation.target.style.display; \n                        mutation.target.style.cssText = '';\n                        mutation.target.style.display = display;\n\n                        mutationObserver.observe(element, { attributes: true, childList: true, subtree: true }); \n\n                    }\n                }\n            }\n        };\n\n        const mutationObserver: MutationObserver = new MutationObserver(mutationCallback);\n\n        // Assuming 'element' is defined and is of type HTMLElement or Element\n        // Start observing the element for attribute changes\n        mutationObserver.observe(element, { attributes: true, childList: true, subtree: true });\n\n    }\n\n    /*\n    // Create a new MutationObserver and provide the callback\n    const observer = new MutationObserver((mutationsList, observer) => {\n        for(let mutation of mutationsList) {\n            if (mutation.type === 'childList') {\n                const addedNodes = Array.from(mutation.addedNodes);\n                const targetElement = addedNodes.find(node => node.id === 'gista-embed-button');\n                if (targetElement) {\n                    handleNewElement(targetElement);\n                    observer.disconnect();  // Disconnect the observer if you only want to detect the element once\n                }\n            }\n        }\n    });\n\n    // Start observing the document with the configured parameters\n    observer.observe(document.body, { childList: true, subtree: true });\n*/ \n\n    // Define the type of the target element\n    type TargetElement = HTMLElement & { id?: string };\n\n    // Create a new MutationObserver and provide the callback\n    const observer = new MutationObserver((mutationsList: MutationRecord[], observer: MutationObserver) => {\n        for(let mutation of mutationsList) {\n            if (mutation.type === 'childList') {\n                const addedNodes: Node[] = Array.from(mutation.addedNodes);\n                const targetElement: TargetElement | undefined = addedNodes.find(node => 'id' in node && node.id === 'gista-embed-button') as TargetElement;\n                if (targetElement) {\n                    handleNewElement(targetElement);\n                    observer.disconnect();  // Disconnect the observer if you only want to detect the element once\n                }\n            }\n        }\n    });\n\n    // Start observing the document with the configured parameters\n    observer.observe(document.body, { childList: true, subtree: true });\n\n}\n\n\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAIA,WAAsB,iBAAiB;AAAA;AAGnC,UAAI,SAAoB,IAAI,UAAU;AACtC,UAAI,YAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWxB,UAAI,UAAmB,OAAO,gBAAgB,WAAW,eAAe,EAAE;AAM1E,eAAS,iBAAiB,SAA4B;AAIlD,gBAAQ,UAAU,IAAI,cAAc;AAGpC,gBAAQ,MAAM,UAAU;AAOxB,YAAI,WAAoC,QAAQ,cAAc,KAAK;AACnE,YAAI,UAAU;AACV,mBAAS,MAAM;AAAA,QACnB;AAOA,cAAM,mBAAqC,CAAC,eAAiCA,cAA+B;AACxG,mBAAQ,YAAY,eAAe;AAG/B,gBAAI,SAAS,SAAS,cAAc;AAEhC,kBAAI,SAAS,kBAAkB,aAAa;AAKxC,oBAAI,SAAS,OAAO,WAAW,SAAS,SAAS,OAAO,aAAa,UAAK;AACtE;AAAA,gBACJ;AAEA,iCAAiB,WAAW;AAE5B,oBAAI,UAAU,SAAS,OAAO,MAAM;AACpC,yBAAS,OAAO,MAAM,UAAU;AAChC,yBAAS,OAAO,MAAM,UAAU;AAEhC,iCAAiB,QAAQ,SAAS,EAAE,YAAY,MAAM,WAAW,MAAM,SAAS,KAAK,CAAC;AAAA,cAE1F;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AAEA,cAAM,mBAAqC,IAAI,iBAAiB,gBAAgB;AAIhF,yBAAiB,QAAQ,SAAS,EAAE,YAAY,MAAM,WAAW,MAAM,SAAS,KAAK,CAAC;AAAA,MAE1F;AAyBA,YAAM,WAAW,IAAI,iBAAiB,CAAC,eAAiCA,cAA+B;AACnG,iBAAQ,YAAY,eAAe;AAC/B,cAAI,SAAS,SAAS,aAAa;AAC/B,kBAAM,aAAqB,MAAM,KAAK,SAAS,UAAU;AACzD,kBAAM,gBAA2C,WAAW,KAAK,UAAQ,QAAQ,QAAQ,KAAK,OAAO,oBAAoB;AACzH,gBAAI,eAAe;AACf,+BAAiB,aAAa;AAC9B,cAAAA,UAAS,WAAW;AAAA,YACxB;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ,CAAC;AAGD,eAAS,QAAQ,SAAS,MAAM,EAAE,WAAW,MAAM,SAAS,KAAK,CAAC;AAAA,IAEtE;AAAA;",
  "names": ["observer"]
}
